<!DOCTYPE html>
<html>
  <head>
    <title>WORM TEST</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>

    <div id="chatBox">
      <div id="chatHistory"></div>
      <input type="text" id="chatInput" placeholder="Chatea con nosotros..." />
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const chatInput = document.getElementById("chatInput");
      let players = {};
      let isChatOpen = false;

      // Ajustar tamaño del canvas al cargar y redimensionar
      function resizeCanvas() {
        // Ahora el canvas ocupa el 100% del viewport
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        drawPlayers(); // Redibuja si es necesario
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      function drawPlayers() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        Object.values(players).forEach((player) => {
          // Dibujar jugador
          ctx.fillStyle = player.color;
          ctx.beginPath();
          ctx.arc(player.x, player.y, 10, 0, Math.PI * 2);
          ctx.fill();

          // Dibujar nombre
          ctx.fillStyle = "black";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText(player.name, player.x, player.y - 15);

          // Dibujar mensajes (máximo 2)
          if (player.messages && player.messages.length > 0) {
            const messageTexts = [...player.messages]
              .reverse()
              .map((msg) => msg.text);
            const combinedText = messageTexts.join("\n");

            ctx.font = "15px Arial";
            ctx.textAlign = "center";

            const lineHeight = 14;
            const lines = combinedText.split("\n");
            const longestLine = lines.reduce(
              (a, b) => (a.length > b.length ? a : b),
              ""
            );
            const textWidth = ctx.measureText("" + longestLine).width;

            const padding = 8;
            const boxWidth = textWidth + padding * 2;
            const boxHeight = lineHeight * lines.length + padding * 1.5;
            const x = player.x - boxWidth / 2;
            const y = player.y - boxHeight - 35;

            // Dibuja la burbuja con pico
            ctx.fillStyle = "rgba(0, 0, 0, 0.50)";
            ctx.strokeStyle = "rgba(0, 0, 0, 0.00)";
            ctx.lineWidth = 0;
            const radius = 4;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + boxWidth - radius, y);
            ctx.quadraticCurveTo(x + boxWidth, y, x + boxWidth, y + radius);
            ctx.lineTo(x + boxWidth, y + boxHeight - radius);
            ctx.quadraticCurveTo(
              x + boxWidth,
              y + boxHeight,
              x + boxWidth - radius,
              y + boxHeight
            );
            ctx.lineTo(x + boxWidth / 2 + 6, y + boxHeight);
            ctx.lineTo(player.x, player.y - 25);
            ctx.lineTo(x + boxWidth / 2 - 6, y + boxHeight);
            ctx.lineTo(x + radius, y + boxHeight);
            ctx.quadraticCurveTo(x, y + boxHeight, x, y + boxHeight - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Dibuja los mensajes dentro
            ctx.fillStyle = "#000";
            lines.forEach((line, i) => {
              ctx.fillText(
                "" + line,
                player.x,
                y + padding + (i + 1) * lineHeight - 4
              );
            });
          }
        });
      }

      // Eventos del servidor
      socket.on("init", (data) => {
        players = { ...data.otherPlayers, [socket.id]: data.currentPlayer };
        drawPlayers();
      });

      socket.on("newPlayer", (newPlayer) => {
        players[newPlayer.id] = newPlayer;
        drawPlayers();
      });

      socket.on("playerMoved", (data) => {
        if (players[data.id]) {
          players[data.id].x = data.x;
          players[data.id].y = data.y;
          drawPlayers();
        }
      });

      socket.on("messageSent", (data) => {
        if (players[data.id]) {
          players[data.id].messages = data.messages;
          drawPlayers();
        }
      });

      socket.on("messageUpdate", (data) => {
        if (players[data.id]) {
          players[data.id].messages = data.messages;
          drawPlayers();
        }
      });

      socket.on("playerDisconnected", (id) => {
        delete players[id];
        drawPlayers();
      });

      // Movimiento con teclado
      document.addEventListener("keydown", (e) => {
        const speed = 20;
        const player = players[socket.id];
        if (!player) return;

        if (isChatOpen) {
          if (e.key === "Escape") {
            chatInput.blur();
            isChatOpen = false;
          }
          return;
        }

        switch (e.key) {
          case "w":
            player.y -= speed;
            break;
          case "s":
            player.y += speed;
            break;
          case "a":
            player.x -= speed;
            break;
          case "d":
            player.x += speed;
            break;
          default:
            return;
        }

        // Limitar al área del canvas
        player.x = Math.max(10, Math.min(canvas.width - 10, player.x));
        player.y = Math.max(10, Math.min(canvas.height - 10, player.y));

        socket.emit("playerMove", { x: player.x, y: player.y });
        drawPlayers();
      });

      // Control del chat
      document.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !isChatOpen) {
          e.preventDefault();
          chatInput.focus();
          isChatOpen = true;
        }
      });

      chatInput.addEventListener("focus", () => {
        isChatOpen = true;
      });

      chatInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          if (chatInput.value.trim() !== "") {
            socket.emit("sendMessage", chatInput.value.trim());
            chatInput.value = "";
          }
          e.preventDefault();
          chatInput.blur();
          isChatOpen = false;
        }
      });

      document.addEventListener("click", (e) => {
        if (e.target !== chatInput && isChatOpen) {
          chatInput.blur();
          isChatOpen = false;
        }
      });

      socket.on("updateChatHistory", (messages) => {
        const chatHistoryDiv = document.getElementById("chatHistory");
        chatHistoryDiv.innerHTML = messages
          .slice() // copiar array para no mutarlo
          .reverse()
          .map(
            (msg) =>
              `<div><strong>${msg.playerName}:</strong> ${msg.text}</div>`
          )
          .join("");
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
      });
    </script>
  </body>
</html>
